% !TEX root = ../Projektdokumentation.tex
\section{Entwurfsphase} 
\label{sec:Entwurfsphase}

\subsection{Zielplattform}
\label{sec:Zielplattform}

Die Extension soll sowohl unter TYPO3 8.7 als auch unter 9.5 und 10.4 Lauffähig sein. Die PHP Version ist 7.2 oder höher. Das JavaScript muss mit allen gängigen Browsern (auch Internet Explorer 11) kompatibel sein.


\subsection{Architekturdesign}
\label{sec:Architekturdesign}

\subsubsection{Backend}
\label{sec:Backend}

\paragraph{Die Configuration Registry} Die Configuration Registry ist eine Singleton-Klasse, die für die Verwaltung von Konfigurationen zuständig ist. Konfigurationen werden mittels eines eindeutigen Keys registriert und bestehen aus mehreren Unterkonfigurationen, welche ebenfalls einen eindeutigen Key besitzen. In einer Unterkonfiguration können entsprechende Einstellungen gesetzt werden und ein sog. Processor definiert werden bzw. dessen Klassenname. Außerdem kann ein Flag gesetzt werden, falls eine Unterkonfiguration nur für das Backend relevant ist und nicht an das Frontend übergeben werden soll. Damit hat eine Konfiguration letztlich folgende Struktur:

\pagebreak

\Abbildung{beispiel_konfiguration} zeigt die grundsätzliche Struktur einer Konfiguration.
\begin{figure}[htb]
\centering
\includegraphicsKeepAspectRatio{beispiel_konfiguration.png}{0.9}
\caption{Beispiel Konfiguration}
\label{fig:beispiel_konfiguration}
\end{figure}

\paragraph{Die Processors} Die Verarbeitung der Dateien geschieht in den zuvor genannten Processors. Diese bestehen aus drei Hooks: onPreload, onUpload und onValidate.

\begin{itemize}
	\item onPreload 	– Mit diesem hook können Dateien für das Preloading vorbereitet werden. Z.B. Thumbnail erzeugen etc.
	\item onUpload 		– Hier werden die Dateien verarbeitet, die vom User hochgeladen werden. Z.B. Validierung der Dateigröße, Thumbnail erzeugen etc.
	\item onValidate	- Dieser Hook dient zur abschließenden Validierung. Z.B. wenn ein Formular submitted wird.
\end{itemize}

\paragraph{Der Ajax Handler} Im Backend wurde als Einstiegspunkt ein Ajax-Handler mit einer Handler-Funktion implementiert. Dafür wurde im TypoScript ein Seitentyp definiert, mittels dem diese Handler-Funktion als userFunc aufgerufen wird, sobald an diesen Seitentyp ein HTTP-Request ankommt. Der Ajax-Handler lädt dann die entsprechende Konfiguration aus der Registry und führt eine entsprechende Fuktion eines Services aus. Dafür muss ihm mitgeteilt werden welche Aktion er ausführen soll. Es gibt die Aktionen Upload und Remove.

\paragraph{Der Service} Der Service bildet die Zentrale anlaufstelle und stellt mehrere Funktionen zur verfügung. Er ist für die Verarbeitung und die Integritätssicherung der Daten zuständig. Er führt die entsprechenden Hooks der Processors aus und liefert daraufhin ein Ergebnis. Zur Integritätssicherung berechnet der Service eine Prüfsumme und stellt eine Funktion zur Validierung bereit.


\subsubsection{Frontend}
\label{sec:Frontend}

\paragraph{Module Bundler} Für das Frontend stellte sich zunächst die Frage, mit welchem Build-Tool bzw. Bundler das JavaScript transpiled und gebundled werden soll. Zu den drei relevantesten bundlern zählen Webpack, Parcel und Rollup.
% TODO

\tabelle{Entscheidungsmatrix Module Bundler}{tab:Entscheidungsmatrix}{Nutzwert.tex}

\paragraph{Typescript} Der Source Code wurde vollständig in TypeScript geschrieben. TypeScript ist eine Programmiersprache entwickelt von Microsoft und bilet eine Obermenge von JavaScript. TypeScript ermöglicht statische Typen währen der Entwicklung zu verwenden. Dadurch ist Typensicherheit gewährleistet und es werden schon im Vorfeld viele Fehlerquellen eliminiert, da die IDE und der TypeScript-(Trans)compiler darauf hinweisen. Außerdem ermöglicht TypeScript, sinnvolle und automatische Code-Vorschläge in der IDE. 
Mittels eines Plugins für Rollup, das den TypeScript-(Trans)compiler aufruft, wird der TypeScript-Code dann in reines JavaScript transpiled. TypeScript wurde für das Projekt so konfiguriert, dass ECMAScript (ES) 5 konforme JavaScript-Syntax (!) erzeugt wird (Ohne Polyfills). Dafür ist zawr normalerweise auch Babel zuständig, es hat sich aber ergeben, dass das Bundle so am Ende kleiner ist, da der TypeScript compiler weniger Overhead erzeugt und den Code einfach hält.

\paragraph{Babel} Babel ist ebenfalls ein Transcompiler, oft auch Transpiler genannt, der JavaScript transformieren kann. Babel wird hauptsächlich dafür verwendet modernen JavaScript-Code so zu transformieren, dass dieser auch mit älteren Browsern kompatibel ist. Dafür gibt es allerhand Plugins, die diese Transformationen vornehmen. Darüber hinaus gibt es Presets, also Zusammenschlüsse aus Plugins und vordefinierten Einstellungen. Eines davon ist das Preset \textbf{@babel/preset-env}, das in diesem Projekt zum Einsatz kommt. Für dieses Preset wird eine sog. Browserslist-Konfiguration definiert. In dieser wird festgelegt, mit welchen Browsern der Code am Ende kompatibel sein muss. Neben reinen syntaktischen Features, wie z.B. Pfeil-Funktionen, async/await etc., erkennt dieses Preset außerdem, wenn Code-Featuers verwendet wurden, die nicht von allen Browsern aus der Browserslist Konfiguration unterstützt werden und importiert automatisch die entsprechenden sog. Polyfills - also Third-Party Implementierungen der Features - aus dem Open Source Projekt \textbf{core-js}. Diese Polyfills treten dann automatisch in Kraft, wenn ein Browser diese Features nicht nativ unterstützt. Z.B. die in der ES6-Spezifikation (oft auch ES 2015 bezeichnet) definierten Array-Funktionen, mit denen man auf funktionale Art mit Arrays umgehen kann oder die ebenfalls mit ES6 eingeführten sog. Promises, mit denen die Arbeit mit asynchronen Operationen sehr vereinfacht wird. Die Browserslist für dieses Projekt wurde so konfiguriert, dass alle relevanten Browser, die sich derzeit am Markt befinden unterstützt werden. Das schließt Browser wie den Internet Explorer 11  mit ein, was Teil der Anforderungen ist. 


\subsection{Geschäftslogik}
\label{sec:Geschaeftslogik}

\begin{itemize}
	\item Modellierung und Beschreibung der wichtigsten (!) Bereiche der Geschäftslogik (\zB mit Kom\-po\-nen\-ten-, Klassen-, Sequenz-, Datenflussdiagramm, Programmablaufplan, Struktogramm, \ac{EPK}).
	\item Wie wird die erstellte Anwendung in den Arbeitsfluss des Unternehmens integriert?
\end{itemize}

\paragraph{Beispiel}
Ein Klassendiagramm, welches die Klassen der Anwendung und deren Beziehungen untereinander darstellt kann im \Anhang{app:Klassendiagramm} eingesehen werden.

\Abbildung{Modulimport} zeigt den grundsätzlichen Programmablauf beim Einlesen eines Moduls als \ac{EPK}.
\begin{figure}[htb]
\centering
\includegraphicsKeepAspectRatio{modulimport.pdf}{0.9}
\caption{Prozess des Einlesens eines Moduls}
\label{fig:Modulimport}
\end{figure}


\subsection{Maßnahmen zur Qualitätssicherung}
\label{sec:Qualitaetssicherung}
\begin{itemize}
	\item Welche Maßnahmen werden ergriffen, um die Qualität des Projektergebnisses (siehe Kapitel~\ref{sec:Qualitaetsanforderungen}: \nameref{sec:Qualitaetsanforderungen}) zu sichern (\zB automatische Tests, Anwendertests)?
	\item \Ggfs Definition von Testfällen und deren Durchführung (durch Programme/Benutzer).
\end{itemize}


\subsection{Pflichtenheft/Datenverarbeitungskonzept}
\label{sec:Pflichtenheft}
\begin{itemize}
	\item Auszüge aus dem Pflichtenheft/Datenverarbeitungskonzept, wenn es im Rahmen des Projekts erstellt wurde.
\end{itemize}

\paragraph{Beispiel}
Ein Beispiel für das auf dem Lastenheft (siehe Kapitel~\ref{sec:Lastenheft}: \nameref{sec:Lastenheft}) aufbauende Pflichtenheft ist im \Anhang{app:Pflichtenheft} zu finden.
